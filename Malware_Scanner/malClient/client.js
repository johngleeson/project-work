/*
   client.js
   Author - John Gleeson

   This program traverses the filesystem, calculates hash values of files and passes
   these values to a server. Once the server responds, the results are sent client.html
 */


var os = require('os');
var fs = require('fs');
var createHash = require('crypto').createHash;
var fileWalker = require('filewalker');
var request = require('request');

var pathToWalk;
var goodCounter = 0;
var threatCounter = 0;
var badCounter = 0;
var fileCounter = 0;
var tempCounter = 0;
var filesPerSecond = 0;
var fileWalkerThrottle = 0;
var startTime;
var endTime;


buttonFunctions();
setInterval(calculateFilesPerSecond, 1000);

/*
    Function to interpret and act on any clicks to the buttons within client.html
 */

function buttonFunctions() {

    $(document).ready(function () {

        //resets info when page is loaded
        resetStats();
        $('#directory_picker').change(function () {
            pathToWalk = $(this).val();
        });


        $('#start_scan').click(function () {

            // reset counters when the scan starts
            resetStats();
            walkFileSystem(pathToWalk);

            //gets the time the button was pressed
            startTime = new Date().getTime();
        });

        var throttleValue = $('#currentValue');

        $('#throttleSlider').change(function () {
            throttleValue.html(this.value);
            fileWalkerThrottle = $(this).val();
        });
        $('#throttleSlider').change();
    });
}

/*
  Calculates and displays the number of files processed per second by the program
 */

function calculateFilesPerSecond() {
    filesPerSecond = fileCounter - tempCounter;
    document.getElementById('fps').innerHTML = filesPerSecond;
    document.getElementById('counter').innerHTML = fileCounter;
    tempCounter = fileCounter;
}

/*
 Function which walks the filesystem. Takes in pathToWalk and
 starts walking the filesystem at this location
 */

function walkFileSystem(pathToWalk) {

    var options = {
        maxPending: fileWalkerThrottle // throttle handles for filewalker

    };
    var fw = fileWalker(pathToWalk, options);

    fw.on('stream', function (readStream, fullPath) {
        var hash = createHash('md5');
        readStream.on('data', function (data) {
            hash.update(data);
        });
        readStream.on('end', function () {

            fileCounter++;
            var fileHash = hash.digest('hex');
            var fileName = fullPath.match(/[^\\/]+$/)[0];

            checkHash(fileHash, fileName, fullPath);
            document.getElementById('current_file').innerHTML = fileName;
        });
    });

    // If an error occurs, this happens
    fw.on('error', function (err) {
        console.error(err);
    });

    // When walking the filesystem is finished, this happens
    fw.on('done', function () {
        finalInfo(fw.bytes);
    });

    // When this is called, the scan begins
    fw.walk();

    process.on('exit', function() {
    });

}

/*
 Called from walkFileSystem and sends its supplied arguments to the server
 */
function checkHash(fileHash, fileName, fullPath) {
    var hostname = os.hostname();

    /*
        d41d8cd98f00b204e9800998ecf8427e HASH OF EMPTY STRING
         if a file is completely empty, don't send it to the server
     */

    if (fileHash !== 'd41d8cd98f00b204e9800998ecf8427e') {

        process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0"; //allows node to use self-signed certs
        request.get({
            url: 'https://localhost:3000/api/checkboth/' + fileHash + '/' + hostname + '/' + fileName + '',
            cert: fs.readFileSync('vendor/cert.pem'),
            key: fs.readFileSync('vendor/key.pem'),
            agent: false
        }, function (error, response, body) {
            if (error) {
                console.log(error);
            } else {
                console.log(body);
            }
        }).on('response', function (response) {
            response.on('data', function (body) {
                if (response.statusCode == 200) {

                    // Once a response is returned , this is called
                    processResponse(body,fullPath,fileName);
                }
            })
        });
    }
}

/*
  This function takes the response from the server, parses it and decides what to
  so with it based on the contents of the response.
 */
function processResponse (body,fullPath,fileName){

    var resultFromServer = JSON.parse(body);
    if (resultFromServer.known_good === true) {

        console.log("Found a good one!", resultFromServer.hash_value, fileName, fullPath);

        addToGoodTable(fileName);
        goodCounter++;
        document.getElementById('known-good').innerHTML = goodCounter.toString().fontcolor("green");
    }

    if (resultFromServer.potentially_bad === true) {
        console.log("Found a suspicious one!", resultFromServer.hash_value, fileName, fullPath);
        addToThreatTable(fileName);
        threatCounter++;
        document.getElementById('threat').innerHTML = threatCounter.toString().fontcolor("orange");
    }

    if (resultFromServer.detectionRate != null) {
        console.log("Found a malicious one!", resultFromServer.hash_value, fileName, fullPath);
        addToBadTable(fileName);
        badCounter++;
        document.getElementById('known-bad').innerHTML = badCounter.toString().fontcolor("red");
    }

}

/*
   A filename is supplied as an argument to this function.
   The filename is then added to goodTable as a row.
 */

function addToGoodTable(fileName) {
    var goodTable = document.getElementById("goodTable").getElementsByTagName('tbody')[0];
    var row = goodTable.insertRow(1);
    var cell1 = row.insertCell(0);
    var cell2 = row.insertCell(1);
    cell1.innerHTML = fileName;
    cell2.innerHTML = "OK".fontcolor('green');
}

/*
 A filename is supplied as an argument to this function.
 The filename is then added to threatTable as a row.
 */
function addToThreatTable(fileName) {
    var threatTable = document.getElementById("threatTable").getElementsByTagName('tbody')[0];
    var row = threatTable.insertRow(1);
    var cell1 = row.insertCell(0);
    var cell2 = row.insertCell(1);
    cell1.innerHTML = fileName;
    cell2.innerHTML = "Possible Malware".fontcolor('orange');
}

/*
 A filename is supplied as an argument to this function.
 The filename is then added to badTable as a row.
 */
function addToBadTable(fileName) {
    var badTable = document.getElementById("badTable").getElementsByTagName('tbody')[0];
    var row = badTable.insertRow(1);
    var cell1 = row.insertCell(0);
    var cell2 = row.insertCell(1);
    cell1.innerHTML = fileName;
    cell2.innerHTML = "Malicious".fontcolor('red');
}

/*
   This function takes in fw.bytes passed in from walkFileSystem and parses it to
   calculate no. of bytes processed etc.
   Also responsible for calculating the time taken for a scan.
 */

function finalInfo(bytes) {
    endTime = new Date().getTime();
    var time = endTime - startTime;
    var convertedTime = convertMS(time);
    var average = fileCounter / (time / 1000);
    var totalBytes = bytes;
    var averageBytes = totalBytes / (time / 1000);
    document.getElementById('current_file').innerHTML = ("Scanning Complete.".fontcolor("red") +
                                                   "" + (" Time taken: "
                                                         + convertedTime.h + " Hours, "
                                                         + convertedTime.m + " Minutes, "
                                                         + convertedTime.s + " Seconds "));
    document.getElementById('average').innerHTML = average.toFixed(0);
    document.getElementById('total').innerHTML = formatInt(totalBytes) + " bytes";
    document.getElementById('averageBytes').innerHTML = formatInt(averageBytes.toFixed(0)) + " bytes/second";
}


/*
 Resets stats when called.
 */

function resetStats() {

    fileCounter = 0;
    document.getElementById('known-good').innerHTML = goodCounter;
    document.getElementById('threat').innerHTML = threatCounter;
    document.getElementById('known-bad').innerHTML = badCounter;
    document.getElementById('counter').innerHTML = fileCounter;
    document.getElementById('current_file').innerHTML = "-";
    document.getElementById('average').innerHTML = "-";
    document.getElementById('total').innerHTML = "-";
    document.getElementById('averageBytes').innerHTML = "-";

}




///////////////////////////////////////////////////////////////////////////////////////////
//
// The below functions were taken directly from the filewaker github page
//  https://github.com/oleics/node-filewalker
//
//////////////////////////////////////////////////////////////////////////////////////////
function formatInt(n) {
    n = thousandSeparator(n);
    return ('                ' + n).slice(-16);
}

function thousandSeparator(n, sep) {
    var sRegExp = new RegExp('(-?[0-9]+)([0-9]{3})'),
        sValue = n + '';

    if (sep === undefined) {
        sep = ',';
    }
    while (sRegExp.test(sValue)) {
        sValue = sValue.replace(sRegExp, '$1' + sep + '$2');
    }
    return sValue;
}

function convertMS(ms) {
    var d, h, m, s;
    s = Math.floor(ms / 1000);
    m = Math.floor(s / 60);
    s = s % 60;
    h = Math.floor(m / 60);
    m = m % 60;
    d = Math.floor(h / 24);
    h = h % 24;
    return {d: d, h: h, m: m, s: s};
}
